/*****************************************************************************
* bsp.c for Lab2A of ECE 153a at UCSB
* Date of the Last Update:  October 27,2019
*****************************************************************************/

/**/
#include "qpn_port.h"
#include "bsp.h"
#include "lab2a.h"
#include "xintc.h"
#include "xil_exception.h"
#include "xparameters.h"
#include <math.h>
#include "xil_cache.h"
#include "xtmrctr.h"
#include "xtmrctr_l.h"
#include "xil_printf.h"
#include "xgpio.h"
#include "xspi.h"
#include "xspi_l.h"
#include "lcd.h"
#include "fsm.h"


/*****************************/

/* Define all variables and Gpio objects here  */

#define GPIO_CHANNEL1 1
#define BUTTON_DEBOUNCE_TIME 100

void debounceInterrupt(); // Write This function

// Create ONE interrupt controllers XIntc
XIntc sys_intc;
// Create two static XGpio variables
static XGpio encoder_gpio;
static XGpio button_gpio;
// Suggest Creating two int's to use for determining the direction of twist
int last_enc_press_time = 0;
int last_btn_press_time = 0;
int curr_turn_state = 0;

// display variables
static XGpio dc;
static XSpi spi;
u32 controlReg;
XSpi_Config *spiConfig;

// timer variables
static XTmrCtr sys_tmrctr;
static unsigned int timer_count = 0;

// Timer Handler
void timer_counter_handler(void *CallBackRef);

/*..........................................................................*/
void BSP_init(void) {
/* Setup LED's, etc */
/* Setup interrupts and reference to interrupt handler function(s)  */

	/*
	 * Initialize the interrupt controller driver so that it's ready to use.
	 * specify the device ID that was generated in xparameters.h
	 *
	 * Initialize GPIO and connect the interrupt controller to the GPIO.
	 *
	 *
	 *
	 */

	// interrupt controller
	XIntc_Initialize(&sys_intc, XPAR_INTC_0_DEVICE_ID);
	XIntc_Start(&sys_intc, XIN_REAL_MODE);

	// encoder gpio
	XGpio_Initialize(&encoder_gpio, XPAR_AXI_GPIO_ENCODER_DEVICE_ID);
	XIntc_Connect(&sys_intc, XPAR_INTC_0_GPIO_2_VEC_ID, (XInterruptHandler)TwistHandler, &encoder_gpio);
	XIntc_Enable(&sys_intc, XPAR_INTC_0_GPIO_2_VEC_ID);
	XGpio_InterruptEnable(&encoder_gpio, GPIO_CHANNEL1);
	XGpio_InterruptGlobalEnable(&encoder_gpio);

	//setup buttons
	XGpio_Initialize(&button_gpio, XPAR_AXI_GPIO_BTN_DEVICE_ID);
	XIntc_Connect(&sys_intc, XPAR_INTC_0_GPIO_1_VEC_ID, (XInterruptHandler)GpioHandler, &button_gpio);
	XIntc_Enable(&sys_intc, XPAR_INTC_0_GPIO_1_VEC_ID);
	XGpio_InterruptEnable(&button_gpio, GPIO_CHANNEL1);
	XGpio_InterruptGlobalEnable(&button_gpio);

	// setup timer
	XTmrCtr_Initialize(&sys_tmrctr, XPAR_AXI_TIMER_0_DEVICE_ID);
	XIntc_Connect(&sys_intc, XPAR_INTC_0_TMRCTR_0_VEC_ID, (XInterruptHandler)timer_counter_handler, &sys_tmrctr);
	XIntc_Enable(&sys_intc, XPAR_INTC_0_TMRCTR_0_VEC_ID);
	XTmrCtr_SetHandler(&sys_tmrctr, timer_counter_handler, &sys_tmrctr);
	XTmrCtr_SetOptions(&sys_tmrctr, 0, XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION);
	XTmrCtr_SetResetValue(&sys_tmrctr, 0, 0xFFFF0000);
	XTmrCtr_Start(&sys_tmrctr, 0);

	// setup spi display
	XGpio_Initialize(&dc, XPAR_SPI_DC_DEVICE_ID);
	XGpio_SetDataDirection(&dc, 1, 0x0);
	spiConfig = XSpi_LookupConfig(XPAR_SPI_DEVICE_ID);
	XSpi_CfgInitialize(&spi, spiConfig, spiConfig->BaseAddress);
	XSpi_Reset(&spi);
	controlReg = XSpi_GetControlReg(&spi);
	XSpi_SetControlReg(&spi,
				(controlReg | XSP_CR_ENABLE_MASK | XSP_CR_MASTER_MODE_MASK) &
				(~XSP_CR_TRANS_INHIBIT_MASK));
	XSpi_SetSlaveSelectReg(&spi, ~0x01);
	initLCD();
	clrScr();

	// enable interrupts
	microblaze_register_handler((XInterruptHandler)XIntc_DeviceInterruptHandler,
			(void*) XPAR_MICROBLAZE_0_AXI_INTC_DEVICE_ID);
	microblaze_enable_interrupts();
}
/*..........................................................................*/
void QF_onStartup(void) {                 /* entered with interrupts locked */

/* Enable interrupts */
	xil_printf("\n\rQF_onStartup\n"); // Comment out once you are in your complete program

	// Press Knob
	// Enable interrupt controller
	// Start interupt controller
	// register handler with Microblaze
	// Global enable of interrupt
	// Enable interrupt on the GPIO

	// Twist Knob

	// General
	// Initialize Exceptions
	// Press Knob
	// Register Exception
	// Twist Knob
	// Register Exception
	// General
	// Enable Exception

	// Variables for reading Microblaze registers to debug your interrupts.
//	{
//		u32 axi_ISR =  Xil_In32(intcPress.BaseAddress + XIN_ISR_OFFSET);
//		u32 axi_IPR =  Xil_In32(intcPress.BaseAddress + XIN_IPR_OFFSET);
//		u32 axi_IER =  Xil_In32(intcPress.BaseAddress + XIN_IER_OFFSET);
//		u32 axi_IAR =  Xil_In32(intcPress.BaseAddress + XIN_IAR_OFFSET);
//		u32 axi_SIE =  Xil_In32(intcPress.BaseAddress + XIN_SIE_OFFSET);
//		u32 axi_CIE =  Xil_In32(intcPress.BaseAddress + XIN_CIE_OFFSET);
//		u32 axi_IVR =  Xil_In32(intcPress.BaseAddress + XIN_IVR_OFFSET);
//		u32 axi_MER =  Xil_In32(intcPress.BaseAddress + XIN_MER_OFFSET);
//		u32 axi_IMR =  Xil_In32(intcPress.BaseAddress + XIN_IMR_OFFSET);
//		u32 axi_ILR =  Xil_In32(intcPress.BaseAddress + XIN_ILR_OFFSET) ;
//		u32 axi_IVAR = Xil_In32(intcPress.BaseAddress + XIN_IVAR_OFFSET);
//		u32 gpioTestIER  = Xil_In32(sw_Gpio.BaseAddress + XGPIO_IER_OFFSET);
//		u32 gpioTestISR  = Xil_In32(sw_Gpio.BaseAddress  + XGPIO_ISR_OFFSET ) & 0x00000003; // & 0xMASK
//		u32 gpioTestGIER = Xil_In32(sw_Gpio.BaseAddress  + XGPIO_GIE_OFFSET ) & 0x80000000; // & 0xMASK
//	}
}


void QF_onIdle(void) {        /* entered with interrupts locked */

    QF_INT_UNLOCK();                       /* unlock interrupts */

    {
    	// Write code to increment your interrupt counter here.
    	QActive_postISR((QActive *)&AO_Lab2A, TIME_TICK); is used to post an event to your FSM



// 			Useful for Debugging, and understanding your Microblaze registers.
//    		u32 axi_ISR =  Xil_In32(intcPress.BaseAddress + XIN_ISR_OFFSET);
//    	    u32 axi_IPR =  Xil_In32(intcPress.BaseAddress + XIN_IPR_OFFSET);
//    	    u32 axi_IER =  Xil_In32(intcPress.BaseAddress + XIN_IER_OFFSET);
//
//    	    u32 axi_IAR =  Xil_In32(intcPress.BaseAddress + XIN_IAR_OFFSET);
//    	    u32 axi_SIE =  Xil_In32(intcPress.BaseAddress + XIN_SIE_OFFSET);
//    	    u32 axi_CIE =  Xil_In32(intcPress.BaseAddress + XIN_CIE_OFFSET);
//    	    u32 axi_IVR =  Xil_In32(intcPress.BaseAddress + XIN_IVR_OFFSET);
//    	    u32 axi_MER =  Xil_In32(intcPress.BaseAddress + XIN_MER_OFFSET);
//    	    u32 axi_IMR =  Xil_In32(intcPress.BaseAddress + XIN_IMR_OFFSET);
//    	    u32 axi_ILR =  Xil_In32(intcPress.BaseAddress + XIN_ILR_OFFSET) ;
//    	    u32 axi_IVAR = Xil_In32(intcPress.BaseAddress + XIN_IVAR_OFFSET);
//
//    	    // Expect to see 0x00000001
//    	    u32 gpioTestIER  = Xil_In32(sw_Gpio.BaseAddress + XGPIO_IER_OFFSET);
//    	    // Expect to see 0x00000001
//    	    u32 gpioTestISR  = Xil_In32(sw_Gpio.BaseAddress  + XGPIO_ISR_OFFSET ) & 0x00000003;
//
//    	    // Expect to see 0x80000000 in GIER
//    		u32 gpioTestGIER = Xil_In32(sw_Gpio.BaseAddress  + XGPIO_GIE_OFFSET ) & 0x80000000;


    }
}

/* Q_onAssert is called only when the program encounters an error*/
/*..........................................................................*/
void Q_onAssert(char const Q_ROM * const Q_ROM_VAR file, int line) {
    (void)file;                                   /* name of the file that throws the error */
    (void)line;                                   /* line of the code that throws the error */
    QF_INT_LOCK();
    printDebugLog();
    for (;;) {
    }
}

/* Interrupt handler functions here.  Do not forget to include them in lab2a.h!
To post an event from an ISR, use this template:
QActive_postISR((QActive *)&AO_Lab2A, SIGNALHERE);
Where the Signals are defined in lab2a.h  */

/******************************************************************************
*
* This is the interrupt handler routine for the GPIO for this example.
*
******************************************************************************/

void timer_counter_handler(void *CallBackRef) {
	Xuint32 ControlStatusReg;
	ControlStatusReg = XTimerCtr_ReadReg(sys_tmrctr.BaseAddress, 0, XTC_TCSR_OFFSET);
	timer_count++;
	XTmrCtr_WriteReg(sys_tmrctr.BaseAddress, 0, XTC_TCSR_OFFSET, ControlStatusReg);
}

void GpioHandler(void *CallbackRef) {
	// Increment A counter
	XGpio *GpioPtr = (XGpio *)CallbackRef;
	if (timer_count - last_btn_press_time < BUTTON_DEBOUNCE_TIME) {
		return;
	}
	int btn_state = XGpio_DiscreteRead(&button_gpio, 1);
	switch (btn_state) {
		case 2:
			QActive_postISR((QActive *)&AO_Lab2A, BUTTON_LEFT);
			break;
		case 4:
			QActive_postISR((QActive *)&AO_Lab2A, BUTTON_RIGHT);
			break;
		case 8:
			QActive_postISR((QActive *)&AO_Lab2A, BUTTON_DOWN);
			break;
		case 16:
			QActive_postISR((QActive *)&AO_Lab2A, BUTTON_CENTER);
			break;
		case 32:
			QActive_postISR((QActive *)&AO_Lab2A, BUTTON_UP);
			break;
	}

	last_btn_press_time = timer_count;
	XGpio_InterruptClear(&button_gpio, GPIO_CHANNEL1);

}

void TwistHandler(void *CallbackRef) {
	XGpio *GpioPtr = (XGpio *)CallbackRef;

	u32 encoder_result = XGpio_DiscreteRead(&encoder_gpio, 1);
	debounceTwistInterrupt(encoder_result);
	debounceInterrupt(encoder_result);
	XGpio_InterruptClear(&encoder_gpio, GPIO_CHANNEL1);
}

void debounceTwistInterrupt(u32 result){
	int encoder_result = result & 3;
	int turn_result = changeState(curr_turn_state, encoder_result);
	curr_turn_state = turn_result >> 4;
	int output = turn_result & 15;

	if (output) {
		QActive_postISR((QActive *)&AO_Lab2A, output == 1 ? ENCODER_UP : ENCODER_DOWN);
	}
}

void debounceInterrupt(u32 result) {
	if (timer_count - last_enc_press_time < BUTTON_DEBOUNCE_TIME) {
		return;
	}
	int encoder_result = (result & 4) >> 2;
	if (encoder_result) {
		QActive_postISR((QActive *)&AO_Lab2A, ENCODER_CLICK);
		last_enc_press_time = timer_count;
	}
}
